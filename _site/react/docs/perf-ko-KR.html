<p>React는 보통 처음에는 꽤 빠릅니다. 하지만 모든 성능을 짜내야 하는 상황일 때를 위해, React는 <a href="/react/docs/component-specs.html#updating-shouldcomponentupdate">shouldComponentUpdate</a> 훅을 제공해 React의 diff 알고리즘을 위한 최적화 힌트를 추가할 수 있습니다.</p>

<p>덧붙여 앱의 전반적인 성능의 개요도 제공합니다. ReactPerf는 프로파일링 도구로 정확히 어디에 훅이 필요한지 알려줍니다.</p>

<blockquote>
<p>주의:</p>

<p>React의 개발 빌드는 제공되는 추가 기능으로 인해 프로덕션 빌드보다 느립니다. 추가 기능에는 React의 친절한 콘솔 경고같은 것이 있습니다.(이는 프로덕션 빌드에서는 제거 됩니다) 따라서, 프로파일러는 앱의 <em>상대적으로</em> 비싼 부분만 표시하도록 합니다.</p>
</blockquote>
<h2><a class="anchor" name="-api"></a>일반 API <a class="hash-link" href="#-api">#</a></h2>
<p>여기에서 설명하는 <code>Perf</code> 객체는 <code>require(&#39;react-addons-perf&#39;)</code>로 노출되고 React 개발 모드에서만 사용할 수 있습니다. 이 번들을 프로덕션에서 앱과 같이 빌드하시면 안됩니다.</p>
<h3><a class="anchor" name="perf.start-perf.stop"></a><code>Perf.start()</code>와 <code>Perf.stop()</code> <a class="hash-link" href="#perf.start-perf.stop">#</a></h3>
<p>측정을 시작/정지합니다. 그 사이의 React 연산은 밑에 있는 분석을 하기위해 기록됩니다. 미미한 양의 연산은 무시됩니다.</p>

<p>종료 후, 측정을 하기위해서는 이후에 설명할 <code>Perf.getLastMeasurements()</code>가 필요합니다.</p>
<h3><a class="anchor" name="perf.printinclusivemeasurements"></a><code>Perf.printInclusive(measurements)</code> <a class="hash-link" href="#perf.printinclusivemeasurements">#</a></h3>
<p>전 수행 시간을 출력합니다. 인자가 넘겨지지 않으면, 기본값은 지난 기록부터의 모든 측정이 됩니다. 이 출력은 밑에 있는 것처럼 콘솔에서 깔끔한 테이블로 그려집니다.</p>

<p><img src="/react/img/docs/perf-inclusive.png" alt=""></p>
<h3><a class="anchor" name="perf.printexclusivemeasurements"></a><code>Perf.printExclusive(measurements)</code> <a class="hash-link" href="#perf.printexclusivemeasurements">#</a></h3>
<p>컴포넌트를 마운트하는 시간을 포함하지 않은 &quot;exclusive&quot; 시간입니다. 여기에는 props 연산, <code>getInitialState</code>, <code>componentWillMount</code> 호출, <code>componentDidMount</code>등이 포함됩니다.</p>

<p><img src="/react/img/docs/perf-exclusive.png" alt=""></p>
<h3><a class="anchor" name="perf.printwastedmeasurements"></a><code>Perf.printWasted(measurements)</code> <a class="hash-link" href="#perf.printwastedmeasurements">#</a></h3>
<p><strong>프로파일러에서 가장 유용한 부분입니다</strong>.</p>

<p>렌더가 같아서, DOM을 변경(touch)하지 않는 경우같은 실제로는 아무것도 렌더하지 않는 컴포넌트가 사용하는 &quot;낭비되는&quot; 시간을 출력합니다.</p>

<p><img src="/react/img/docs/perf-wasted.png" alt=""></p>
<h3><a class="anchor" name="perf.printdommeasurements"></a><code>Perf.printDOM(measurements)</code> <a class="hash-link" href="#perf.printdommeasurements">#</a></h3>
<p>&quot;set innerHTML&quot;이나 &quot;remove&quot;같은 기저의 DOM 조작을 출력합니다.</p>

<p><img src="/react/img/docs/perf-dom.png" alt=""></p>
<h2><a class="anchor" name="-api"></a>고급 API <a class="hash-link" href="#-api">#</a></h2>
<p>위의 출력 메소드에 <code>Perf.getLastMeasurements()</code>를 사용해 결과를 이쁘게 출력합니다.</p>
<h3><a class="anchor" name="perf.getlastmeasurements"></a><code>Perf.getLastMeasurements()</code> <a class="hash-link" href="#perf.getlastmeasurements">#</a></h3>
<p>마지막 start-stop 세션에서 측정들의 배열을 가져옵니다. 이 배열은 이런 객체들을 가지고 있습니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="p">{</span>
  <span class="c1">// 용어 &quot;inclusive&quot;와 &quot;exclusive&quot;는 위에서 설명했음</span>
  <span class="s2">&quot;exclusive&quot;</span><span class="o">:</span> <span class="p">{},</span>
  <span class="c1">// &#39;.0.0&#39;는 노드의 React ID</span>
  <span class="s2">&quot;inclusive&quot;</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;.0.0&quot;</span><span class="o">:</span> <span class="mf">0.0670000008540228</span><span class="p">,</span> <span class="s2">&quot;.0&quot;</span><span class="o">:</span> <span class="mf">0.3259999939473346</span><span class="p">},</span>
  <span class="s2">&quot;render&quot;</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;.0&quot;</span><span class="o">:</span> <span class="mf">0.036999990697950125</span><span class="p">,</span> <span class="s2">&quot;.0.0&quot;</span><span class="o">:</span> <span class="mf">0.010000003385357559</span><span class="p">},</span>
  <span class="c1">// 인스턴스의 수</span>
  <span class="s2">&quot;counts&quot;</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;.0&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;.0.0&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">},</span>
  <span class="c1">// DOM 변경(touch)</span>
  <span class="s2">&quot;writes&quot;</span><span class="o">:</span> <span class="p">{},</span>
  <span class="c1">// 추가 디버깅 정보</span>
  <span class="s2">&quot;displayNames&quot;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;.0&quot;</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;current&quot;</span><span class="o">:</span> <span class="s2">&quot;App&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="o">:</span> <span class="s2">&quot;&lt;root&gt;&quot;</span><span class="p">},</span>
    <span class="s2">&quot;.0.0&quot;</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;current&quot;</span><span class="o">:</span> <span class="s2">&quot;Box&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="o">:</span> <span class="s2">&quot;App&quot;</span><span class="p">}</span>
  <span class="p">},</span>
  <span class="s2">&quot;totalTime&quot;</span><span class="o">:</span> <span class="mf">0.48499999684281647</span>
<span class="p">}</span>
</code></pre></div>