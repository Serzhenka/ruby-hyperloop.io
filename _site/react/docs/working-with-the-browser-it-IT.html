<p>React offre potenti astrazioni che ti liberano in molti casi dal compito di manipolare direttamente il DOM, ma a volte potresti avere bisogno di accedere alle API sottostanti, ad esempio per lavorare con una libreria di terze parti o altro codice preesistente.</p>
<h2><a class="anchor" name="il-dom-virtuale"></a>Il DOM Virtuale <a class="hash-link" href="#il-dom-virtuale">#</a></h2>
<p>React è così veloce perché non interagisce direttamente con il DOM. React gestisce una rappresentazione veloce del DOM in memoria. I metodi <code>render()</code> restituiscono una <em>descrizione</em> del DOM, e React può confrontare questa descrizione con la rappresentazione in memoria per calcolare la maniera più veloce di aggiornare il browser.</p>

<p>In aggiunta, React implementa un intero sistema di eventi sintetici che fa in modo che tutti gli oggetti evento siano conformi alle specifiche W3C nonostante le incompatibilità dei browser, e ciascun evento si propaga in maniera consistente ed efficiente in ogni browser. Puoi anche utilizzare alcuni eventi HTML5 in IE8!</p>

<p>Nella maggior parte dei casi è sufficiente rimanere nel mondo del &quot;browser fittizio&quot; di React poiché più efficiente e facile da concepire. Tuttavia, a volte potresti aver bisogno di accedere alle API sottostanti, ad esempio per lavorare con una libreria di terze parti come un plugin jQuery. React fornisce convenienti vie di fuga perché tu possa utilizzare direttamente le API DOM sottostanti.</p>
<h2><a class="anchor" name="i-ref-e-finddomnode"></a>I Ref e findDOMNode() <a class="hash-link" href="#i-ref-e-finddomnode">#</a></h2>
<p>Per interagire con il browser, avrai bisogno di un riferimento a un nodo DOM. Puoi assegnare un attributo <code>ref</code> a ciascun elemento, ciò ti permette di fare riferimento all&#39;<strong>istanza di supporto</strong> del componente. Questo è utile se devi invocare funzioni imperative sul componente, oppure desideri accedere ai nodi DOM sottostanti. Per saperne di piu sui ref, incluso la maniera di usarli con efficacia, leggi la nostra documentazione <a href="/react/docs/more-about-refs-it-IT.html">riferimenti a componenti</a>.</p>
<h2><a class="anchor" name="ciclo-di-vita-del-componente"></a>Ciclo di Vita del Componente <a class="hash-link" href="#ciclo-di-vita-del-componente">#</a></h2>
<p>I componenti hanno tree fasi principali del ciclo di vita:</p>

<ul>
<li><strong>Montaggio:</strong> Un componente sta venendo inserito nel DOM.</li>
<li><strong>Aggiornamento:</strong> Viene effettuato nuovamente il rendering del componente per determinare se il DOM vada aggiornato.</li>
<li><strong>Smontaggio:</strong> Un componente sta venendo rimosso dal DOM.</li>
</ul>

<p>React offre metodi del ciclo di vita che puoi specificare per inserirti in questo processo. Offriamo dei metodi il cui nome inizia per <strong>will</strong>, chiamati immediatamente prima che qualcosa accada, o per <strong>did</strong> che sono chiamati immediatamente dopo che qualcosa è accaduto.</p>
<h3><a class="anchor" name="montaggio"></a>Montaggio <a class="hash-link" href="#montaggio">#</a></h3>
<ul>
<li><code>getInitialState(): object</code> è invocato prima che un componente viene montato. Componenti dotati di stato dovrebbero implementare questo metodo e restituire lo stato iniziale.</li>
<li><code>componentWillMount()</code> è invocato immediatamente prima che si effettui il montaggio.</li>
<li><code>componentDidMount()</code> è invocato immediatamente dopo che il montaggio è avvenuto. L&#39;inizializzazione che richiede l&#39;esistenza di nodi DOM dovrebbe avvenire in questo metodo.</li>
</ul>
<h3><a class="anchor" name="aggiornamento"></a>Aggiornamento <a class="hash-link" href="#aggiornamento">#</a></h3>
<ul>
<li><code>componentWillReceiveProps(object nextProps)</code> è invocato quando un componente montato riceve nuove proprietà. Questo metodo dovrebbe essere utilizzato per confrontare <code>this.props</code> e <code>nextProps</code> per effettuare transizioni di stato utilizzando <code>this.setState()</code>.</li>
<li><code>shouldComponentUpdate(object nextProps, object nextState): boolean</code> è invocato quando un componente decide se i cambiamenti debbano risultare in un aggiornamento del DOM. Implementa questo metodo come un&#39;ottimizzazione per confrontare <code>this.props</code> con <code>nextProps</code> e <code>this.state</code> con <code>nextState</code>, e restituisci <code>false</code> se React debba rimandare l&#39;aggiornamento.</li>
<li><code>componentWillUpdate(object nextProps, object nextState)</code> è invocato immediatamente prima che l&#39;aggiornamento avvenga. Non puoi chiamare <code>this.setState()</code> al suo interno.</li>
<li><code>componentDidUpdate(object prevProps, object prevState)</code> è invocato immediatamente dopo che l&#39;aggiornamento è avvenuto.</li>
</ul>
<h3><a class="anchor" name="smontaggio"></a>Smontaggio <a class="hash-link" href="#smontaggio">#</a></h3>
<ul>
<li><code>componentWillUnmount()</code> è invocato immediatamente prima che un componente venga smontato e distrutto. Puoi effettuare operazioni di pulizia al suo interno.</li>
</ul>
<h3><a class="anchor" name="metodi-montati"></a>Metodi Montati <a class="hash-link" href="#metodi-montati">#</a></h3>
<p>Componenti compositi <em>montati</em> supportano anche i seguenti metodi:</p>

<ul>
<li><code>findDOMNode(): DOMElement</code> può essere invocato su ciascun componente montato per ottenere un riferimento al suo nodo DOM.</li>
<li><code>forceUpdate()</code> può essere invocato su ciascun componente montato quando si è certi che un aspetto interno del componente è cambiato senza usare <code>this.setState()</code>.</li>
</ul>
<h2><a class="anchor" name="supporto-per-i-browser-e-polyfill"></a>Supporto per i Browser e Polyfill <a class="hash-link" href="#supporto-per-i-browser-e-polyfill">#</a></h2>
<p>A Facebook supportiamo vecchi browser, incluso IE8. Abbiamo impiegato per un lungo tempo i polyfill per consentirci di scrivere JS con un occhio al futuro. Ciò significa che non abbiamo una quantità di hack sparsi nel nostro codice e possiamo tuttavia aspettarci che il nostro codice &quot;semplicemente funzioni&quot;. Ad esempio, anziché usare <code>+new Date()</code>, possiamo scrivere <code>Date.now()</code>. Dal momento che la versione open source di React è la stessa che usiamo internamente, vi abbiamo applicato la stessa filosofia di scrivere JS guardando avanti.</p>

<p>In aggiunta a questa filosofia, abbiamo anche deciso, in qualità di autori di una libreria JS, non dovremmo fornire i polyfill assieme alla nostra libreria. Se ciascuna libreria facesse ciò, con buona probabilità invieresti lo stesso polyfill diverse volte, cosa che potrebbe risultare in una rilevante quantità di codice inutilizzato. Se il tuo prodotto deve supportare vecchi browser, con buona probabilità stai già usando qualcosa come <a href="https://github.com/es-shims/es5-shim">es5-shim</a>.</p>
<h3><a class="anchor" name="polyfill-richiesti-per-supportare-vecchi-browser"></a>Polyfill Richiesti per Supportare Vecchi Browser <a class="hash-link" href="#polyfill-richiesti-per-supportare-vecchi-browser">#</a></h3>
<p><code>es5-shim.js</code> tratto da <a href="https://github.com/es-shims/es5-shim">es5-shim di kriskowal</a> fornisce le seguenti API indispensabili a React:</p>

<ul>
<li><code>Array.isArray</code></li>
<li><code>Array.prototype.every</code></li>
<li><code>Array.prototype.forEach</code></li>
<li><code>Array.prototype.indexOf</code></li>
<li><code>Array.prototype.map</code></li>
<li><code>Date.now</code></li>
<li><code>Function.prototype.bind</code></li>
<li><code>Object.keys</code></li>
<li><code>String.prototype.split</code></li>
<li><code>String.prototype.trim</code></li>
</ul>

<p><code>es5-sham.js</code>, anch&#39;esso tratto da <a href="https://github.com/es-shims/es5-shim">es5-shim di kriskowal</a>, provides the following that React needs:</p>

<ul>
<li><code>Object.create</code></li>
<li><code>Object.freeze</code></li>
</ul>

<p>La build non minificata di React richiede le seguenti API tratte da <a href="https://github.com/paulmillr/console-polyfill">console-polyfill di paulmillr</a>.</p>

<ul>
<li><code>console.*</code></li>
</ul>

<p>Quando si usano elementi HTML5 in IE8 incluso <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;header&gt;</code> e <code>&lt;footer&gt;</code>, è inoltre necessario includere <a href="https://github.com/aFarkas/html5shiv">html5shiv</a> o uno script equivalente.</p>
<h3><a class="anchor" name="problemi-cross-browser"></a>Problemi Cross-browser <a class="hash-link" href="#problemi-cross-browser">#</a></h3>
<p>Nonostante React sia molto buono ad astrarre le differenze tra browser, alcuni browser sono limitati o presentano comportamenti scorretti per i quali non abbiamo potuto trovare un rimedio.</p>
<h4><a class="anchor" name="evento-onscroll-su-ie8"></a>Evento onScroll su IE8 <a class="hash-link" href="#evento-onscroll-su-ie8">#</a></h4>
<p>Su IE8 l&#39;evento <code>onScroll</code> non viene propagato, e IE8 non possiede una API per definire gestori di eventi nella fase di cattura dell&#39;evento, con il risultato che React non ha alcun modo di reagire a questi eventi.
Al momento i gestori di questo evento vengono ignorati su IE8.</p>

<p>Leggi la issue <a href="https://github.com/facebook/react/issues/631">onScroll doesn&#39;t work in IE8</a> su GitHub per maggiori informazioni.</p>
