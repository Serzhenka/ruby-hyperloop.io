<p>React ti permette di usare qualunque stile per la gestione dei dati che desideri, incluso la mutazione. Tuttavia, se puoi usare dati immutabili in parti critiche per le prestazioni della tua applicazione è facile implementare rapidamente un metodo <code>shouldComponentUpdate()</code> che aumenta significativamente la velocità della tua applicazione.</p>

<p>Avere a che fare con dati immutabili in JavaScript è più difficile che in linguaggi progettati a tale scopo, come <a href="http://clojure.org/">Clojure</a>. Tuttavia, abbiamo fornito un semplice helper per l&#39;immutabilità, <code>update()</code>, che rende avere a che fare con questo tipo di dati molto più semplice, <em>senza</em> cambiare fondamentalmente la rappresentazione dei tuoi dati. Se puoi anche dare un&#39;occhiata alla libreria <a href="https://facebook.github.io/immutable-js/docs/">Immutable-js</a> di Facebook e la sezione <a href="/react/docs/advanced-performance.html">Prestazioni Avanzate</a> per maggiori dettagli su Immutable-js.</p>
<h2><a class="anchor" name="lidea-fondamentale"></a>L&#39;idea fondamentale <a class="hash-link" href="#lidea-fondamentale">#</a></h2>
<p>Se muti i tuoi dati nella seguente maniera:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">myData</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="c1">// oppure...</span>
<span class="nx">myData</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</code></pre></div>
<p>non hai modo di determinare quali dati siano cambiati dal momento che la copia precedente è stata sovrascritta. Invece, devi creare una nuova copia di <code>myData</code> e cambiare solo le parti che vanno cambiate. Allora puoi confrontare la vecchia copia di <code>myData</code> con la nuova in <code>shouldComponentUpdate()</code> usando l&#39;operatore di uguaglianza stretta <code>===</code>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="nx">deepCopy</span><span class="p">(</span><span class="nx">myData</span><span class="p">);</span>
<span class="nx">newData</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="nx">newData</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</code></pre></div>
<p>Sfortunatamente, le copie profonde sono costose, e a volte impossibili. Puoi alleviare questa limitazione copiando soltanto gli oggetti che devono essere cambiati e riutilizzando gli oggetti che nonsono cambiati. Sfortunatamente, nel JavaScript odierno questa può essere un&#39;operazione difficoltosa:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">myData</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">x</span><span class="o">:</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">myData</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">y</span><span class="o">:</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">myData</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="p">{</span><span class="nx">z</span><span class="o">:</span> <span class="mi">7</span><span class="p">}),</span>
  <span class="p">}),</span>
  <span class="nx">a</span><span class="o">:</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">myData</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="nx">myData</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="mi">9</span><span class="p">)})</span>
<span class="p">});</span>
</code></pre></div>
<p>Mentre questo codice ha prestazioni accettabili (dal momento che effettua soltanto una copia superficiale di <code>log n</code> oggetti e riutilizza i rimanenti), è una gran scocciatura da scrivere. Guarda quanta ripetizione! Questo non è soltanto fastidioso, ma offre una grande superficie di attacco per i bachi.</p>

<p><code>update()</code> fornisce un semplice zucchero sintattico attorno a questo pattern per rendere più semplice la scrittura di questo codice. Questo codice diventa:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">addons</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">myData</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">x</span><span class="o">:</span> <span class="p">{</span><span class="nx">y</span><span class="o">:</span> <span class="p">{</span><span class="nx">z</span><span class="o">:</span> <span class="p">{</span><span class="nx">$set</span><span class="o">:</span> <span class="mi">7</span><span class="p">}}},</span>
  <span class="nx">a</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="p">{</span><span class="nx">$push</span><span class="o">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">]}}</span>
<span class="p">});</span>
</code></pre></div>
<p>Mentre la sintassi richiede qualche tempo per abituarsi (anche se è ispirata dal <a href="http://docs.mongodb.org/manual/core/crud-introduction/#query">linguaggio di query di MongoDB</a>) non c&#39;è ridondanza, può essere analizzato staticamente e non richiede la scrittura di più codice della versione mutativa.</p>

<p>Le chiavi con il prefisso <code>$</code> sono chiamate <em>comandi</em>. La struttura dati che stanno &quot;mutando&quot; viene chiamata <em>bersaglio</em>.</p>
<h2><a class="anchor" name="comandi-disponibili"></a>Comandi disponibili <a class="hash-link" href="#comandi-disponibili">#</a></h2>
<ul>
<li><code>{$push: array}</code> invoca <code>push()</code> sul bersagio passando ciascun elemento di <code>array</code>.</li>
<li><code>{$unshift: array}</code> invoca <code>unshift()</code> sul bersagio passando ciascun elemento di <code>array</code>.</li>
<li><code>{$splice: array of arrays}</code> per ogni elemento di <code>arrays</code> invoca <code>splice()</code> sul bersaglio con i parametri forniti dall&#39;elemento.</li>
<li><code>{$set: any}</code> sostituisce l&#39;intero bersaglio.</li>
<li><code>{$merge: object}</code> unisce le chiavi di <code>object</code> con il bersaglio.</li>
<li><code>{$apply: function}</code> passa il valore attuale alla funzione e lo aggiorna con il nuovo valore da essa restituito.</li>
</ul>
<h2><a class="anchor" name="esempi"></a>Esempi <a class="hash-link" href="#esempi">#</a></h2><h3><a class="anchor" name="semplice-inserimento-in-coda"></a>Semplice inserimento in coda <a class="hash-link" href="#semplice-inserimento-in-coda">#</a></h3><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">initialArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">update</span><span class="p">(</span><span class="nx">initialArray</span><span class="p">,</span> <span class="p">{</span><span class="nx">$push</span><span class="o">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]});</span> <span class="c1">// =&gt; [1, 2, 3, 4]</span>
</code></pre></div>
<p><code>initialArray</code> is still <code>[1, 2, 3]</code>.</p>
<h3><a class="anchor" name="collezioni-annidate"></a>Collezioni annidate <a class="hash-link" href="#collezioni-annidate">#</a></h3><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">collection</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">]}];</span>
<span class="kd">var</span> <span class="nx">newCollection</span> <span class="o">=</span> <span class="nx">update</span><span class="p">(</span><span class="nx">collection</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="p">{</span><span class="nx">$splice</span><span class="o">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">]]}}});</span>
<span class="c1">// =&gt; [1, 2, {a: [12, 13, 14, 15]}]</span>
</code></pre></div>
<p>Questo accede all&#39;indice <code>2</code> di <code>collection</code>, alla chiave <code>a</code>, ed effettua lo splice di un elemento a partire dall&#39;indice <code>1</code> (per rimuovere <code>17</code>) e al contempo inserisce <code>13</code> e <code>14</code>.</p>
<h3><a class="anchor" name="aggiornare-un-valore-basandosi-sul-suo-valore-attuale"></a>Aggiornare un valore basandosi sul suo valore attuale <a class="hash-link" href="#aggiornare-un-valore-basandosi-sul-suo-valore-attuale">#</a></h3><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">newObj</span> <span class="o">=</span> <span class="nx">update</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="p">{</span><span class="nx">$apply</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;}}});</span>
<span class="c1">// =&gt; {a: 5, b: 6}</span>
<span class="c1">// Questa è una forma equivalente, ma diventa prolissa per profonde collezioni annidate:</span>
<span class="kd">var</span> <span class="nx">newObj2</span> <span class="o">=</span> <span class="nx">update</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="p">{</span><span class="nx">$set</span><span class="o">:</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">b</span> <span class="o">*</span> <span class="mi">2</span><span class="p">}});</span>
</code></pre></div><h3><a class="anchor" name="unione-superficiale"></a>Unione (superficiale) <a class="hash-link" href="#unione-superficiale">#</a></h3><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">3</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">newObj</span> <span class="o">=</span> <span class="nx">update</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span><span class="nx">$merge</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="o">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">7</span><span class="p">}});</span> <span class="c1">// =&gt; {a: 5, b: 6, c: 7}</span>
</code></pre></div>