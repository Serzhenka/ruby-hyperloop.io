---
id: jsx-in-depth
title: JSX in Depth
permalink: jsx-in-depth.html
prev: displaying-data.html
next: jsx-spread.html
---

## The React.rb DSL

The React.rb DSL is a set of class and instance methods that are used within a React component to describe the components behavior.

The DSL has the following major areas:  
* The `React::Component::Base` class and the equivilent `React::Component` mixin.
* Class methods or "macros" that describe component class level behaviors.
* The three data accessors methods: `params`, `state`, and `children`.
* The tag and component rendering.
* Event handlers
* Miscellaneous methods

To understand the DSL we will walk through an example that will cover each of these areas in detail.

```ruby
class Clock < React::Component::Base
  
  param mode: 12
  
  before_mount do
    state.mode! params.mode
  end
  
  after_mount do 
    @timer = every(60) { force_update! }
  end
  
  before_unmount do
    @timer.stop
  end
  
  FORMATS = {
    12 => "%a, %e %b %Y %I:%M %p",
    24 => "%a, %e %b %Y %H:%M"
    }
  
  def render
    div(class: :time) do
      Time.now.strftime(FORMATS[state.mode]).span
      select(style: {"margin-left" => 20}, value: state.mode)  do
        option(value: 12) { "12 Hour Clock" }
        option(value: 24) { "24 Hour Clock" }
      end.on(:change) do |e|
        state.mode!(e.target.value.to_i)
      end
    end
  end
end

Element['#container'].render do 
  Clock(mode: 12)
end
```

#### React::Component::Base

```ruby
class Clock < React::Component::Base
...
end
```

Component classes can be be created by inheriting from React::Component::Base.  You may also create a component class by mixing in the `React::Component` module:

```ruby
class Clock2
  include React::Component
  ...
end
```

#### Macros (Class Methods)

```ruby
class Clock < React::Component::Base
  param ...
  before_mount ...
  after_mount ...
  before_unmount ...
  ...
end
```

Macros specify class wide behaviors.  In our example we use the 4 most common macros.  

The `param macro indicates that we expect a param called `mode` to be passed.

The `before_mount` macro defines code to be run (a callback) when a component instance is first initialized. 

The `after_mount` macro likewise runs after the instance has completed initialization, and is visible in the DOM.

The `before_unmount` macro provides any cleanup actions before the instance is destroyed.

The available macros are: `param, export_state, before_mount, after_mount, before_receive_props, before_update, after_update, before_unmount`

#### Data Accessor Methods

The three data accessor methods - `params, state, and children` are instance methods that give access to a components react specific instance data.

The `params` method gives (read only) access to each of the params passed to this instance, the `state` method allows state variables to be read and written, and `children` returns an enumerator of a components children.

In or example we see
```ruby
  before_mount do
    state.mode! params.mode
  end
```

`params.mode` will return the value of the `mode` parameter passed to this instance, and `state.mode!` initializes (or updates) the `mode` state variable.  State variables are like "reactive" instance variables.  They can only be changed using the "!" method, and when they change they will cause a rerender.  

More on the details of these methods can be found in the [Component API](/docs/component-api.html) section.

#### Tag and Component Rendering

```ruby
  ...
    div(class: :time) do
      ...
    end
  ...
```

HTML such as `div, a, select, option` etc each have a corresponding instance method that will render that tag.  For all the tags the 
method call looks like this: 

```ruby
tag_name(attribute1 => value1, attribute2 => value2 ..) do 
  ...nested tags... 
end
```

All HTML tags are supported, but the "p" tag changes to "para".

Each key-value pair in the parameter block is passed down as an attribute to the tag as you would expect, with the exception of the style attribute, which takes a hash that is translated to the corresponding style string.

The same rules apply for application defined components, except that the class constant is used to reference the component.

```ruby
  Clock(mode: 12)
```


Strings are treated specially as follows:  

* If a render method or a nested tag block returns a string, the string is automatically wrapped in a `<span>` tag.
* The code `span { "hello" }` can be shortened to "hello".span, likewise for `td, para, td, th` tags.
* `"some string".br` generates `<span>some string<span><br/>`

```ruby
  Time.now.strftime(FORMATS[state.mode]).span  # generates <span>...current time formatted...</span>
  ...
    option(value: 12) { "12 Hour Clock" }      # generates <option value=12><span>12 Hour Clock</span></option>
```

HAML style class names:

Any tag or component name can be followed by `.class_name` HAML style.

```ruby
  div.class1.class2
  # short for
  div(class: "class1 class2")
```

#### Event Handlers

Event Handlers are attached to tags and components using the `on` method.

```ruby
      select ... do
        ...
      end.on(:change) do |e|
        state.mode!(e.target.value.to_i)
      end
```

The `on` method takes the event name symbol (note that onClick becomes :click) and the block is passed the React.js event object.

Event handlers can be chained like so 

```ruby
  input ... do
    ...
  end.on(:key_up) do |e|
    ...
  end.on(:change) do |e|
    ...
  end
```

#### Miscellaneous Methods

* `force_update!` is a Component instance method that causes the component to re-rerender
* `as_node` can be attached to a component or tag, and removes the element from the rendering buffer and returns it.   This is useful when you need to pass an element as a param to another component. 


#### Ruby and React.rb

A key design goal of the DSL is to make it work seamlessly with the rest of Ruby.  Notice in the above example use of the constant declaration (`FORMATS`), regular instance variables (`@timer`), and other non-react methods like `every` (an Opal Browser method).  

Component classes can be organized like any other class into a logical module hierarchy or even subclassed.

Likewise the render method can invoke other methods to compute values or even internally build tags.
